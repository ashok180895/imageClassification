# -*- coding: utf-8 -*-
"""Fuzzy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pmrk3dOl_VJgEVF4BEwG1W4h03if8l9k
"""

from google.colab import drive

drive.mount('/content/gdrive')

import pandas as pd # reading all required header files
import numpy as np
import random
import operator
import math
import matplotlib.pyplot as plt 
from scipy.stats import multivariate_normal

#Reading the dataset using pandas
df_full = pd.read_csv("/content/gdrive/MyDrive/completeDataset.csv")

# Removing the unneccessary column from the dataset

dfi=df_full

dfi=dfi.drop(dfi.columns[0],axis=1)
print(dfi.head(),dfi.shape)

#seperating the targets and features to fed into FCM
df_full=dfi
columns = list(df_full.columns)
features = columns[:len(columns)-1]
class_labels = list(df_full[columns[-1]])
df = df_full[features]

#Checking if features are right in place
print(df.head())
#print(len(class_labels))

#Hyper parameters
# Number of Clusters
k = 11
# Maximum number of iterations 
MAX_ITER = 10
# Number of data points
n = len(df)
# Fuzzy parameter
m = 1.7 #Select a value greater than 1 else it will be knn

def initializeMembershipMatrix(): # initializing the membership matrix for the data points
    membership_mat = []
    for i in range(n):
        random_num_list = [random.random() for i in range(k)]
        summation = sum(random_num_list)
        temp_list = [x/summation for x in random_num_list]
        
        flag = temp_list.index(max(temp_list))
        for j in range(0,len(temp_list)):
            if(j == flag):
                temp_list[j] = 1
            else:
                temp_list[j] = 0
        
        membership_mat.append(temp_list)
    return membership_mat

#calling membership matrix function
membership_mat = initializeMembershipMatrix()

def calculateClusterCenter(membership_mat): # calculating the cluster centers
    cluster_mem_val = list(zip(*membership_mat))
    cluster_centers = []
    for j in range(k):
        #print(j)
        x = list(cluster_mem_val[j])
        xraised = [p ** m for p in x]
        denominator = sum(xraised)
        temp_num = []
        for i in range(n):
            data_point = list(df.iloc[i])
            prod = [xraised[i] * val for val in data_point]
            temp_num.append(prod)
        numerator = map(sum, list(zip(*temp_num)))
        center = [z/denominator for z in numerator]
        cluster_centers.append(center)
    return cluster_centers

#Calculating the clusters centers
calculateClusterCenter(membership_mat)

#Here Accuracy is calculated by dividing the labels nearly equal chunks and finding max membership value.
#each data point can represent to the one cluster which is done in for loop and returning the accuracy.
def accuracy(cluster_labels, class_labels):
    correct_pred = 0
    #print(cluster_labels)
    l0 = max(set(labels[0:7000]), key=labels[0:7000].count)
    l1 = max(set(labels[7000:14000]), key=labels[7000:14000].count)
    l2 = max(set(labels[14000:21000]), key=labels[14000:21000].count)
    l3 = max(set(labels[21000:28000]), key=labels[21000:28000].count)
    l4 = max(set(labels[28000:35000]), key=labels[28000:35000].count)
    l5 = max(set(labels[35000:42000]), key=labels[35000:42000].count)
    l6 = max(set(labels[42000:49000]), key=labels[42000:49000].count)
    l7 = max(set(labels[49000:56000]), key=labels[49000:56000].count)
    l8 = max(set(labels[56000:63000]), key=labels[56000:63000].count)
    l9 = max(set(labels[63000:70000]), key=labels[63000:70000].count)
    l10 = max(set(labels[70000:]), key=labels[70000:].count)
    for i in range(len(df)):
        if cluster_labels[i] == l0 and class_labels[i] == 0:
            correct_pred = correct_pred + 1
        if cluster_labels[i] == l1 and class_labels[i] == 1 and l1!=l0:
            correct_pred = correct_pred + 1
        if cluster_labels[i] == l2 and class_labels[i] == 2 and l2!=l0 and l2!=l1:
            correct_pred = correct_pred + 1
        if cluster_labels[i] == l3 and class_labels[i] == 3 and l3!=l0 and l3!=l1 and l3!=l2:
            correct_pred = correct_pred + 1
        if cluster_labels[i] == l4 and class_labels[i] == 4 and l4!=l0 and l4!=l1 and l4!=l2 and l4!=l3:
            correct_pred = correct_pred + 1
        if cluster_labels[i] == l5 and class_labels[i] == 5 and l5!=l0 and l5!=l1 and l5!=l2 and l5!=l3 and l5!=l4 :
            correct_pred = correct_pred + 1
        if cluster_labels[i] == l6 and class_labels[i] == 6 and l6!=l0 and l6!=l1 and l6!=l5 and l6!=l2 and l6!=l3 and l6!=l4:
            correct_pred = correct_pred + 1    
        if cluster_labels[i] == l7 and class_labels[i] == 7 and l7!=l0 and l7!=l1 and l7!=l5 and l7!=l2 and l7!=l3 and l7!=l4 and l7!=l6:
            correct_pred = correct_pred + 1    
        if cluster_labels[i] == l8 and class_labels[i] == 8 and l8!=l0 and l8!=l1 and l8!=l2 and l8!=l3 and l8!=l4 and l8!=l5 and l8!=l6 and l8!=l7:
            correct_pred = correct_pred + 1    
        if cluster_labels[i] == l9 and class_labels[i] == 9 and l9!=l0 and l9!=l1 and l9!=l2 and l9!=l3 and l9!=l4 and l9!=l5 and l9!=l6 and l9!=l7 and l9!=l8:
            correct_pred = correct_pred + 1    
        if cluster_labels[i] == l10 and class_labels[i] == 10 and l10!=l0 and l10!=l1 and l10!=l2 and l10!=l3 and l10!=l4 and l10!=l5 and l10!=l6 and l10!=l7 and l10!=l8 and l10!=l9:
            correct_pred = correct_pred + 1    

    accuracy = (correct_pred/len(df))*100
    return accuracy

def updateMembershipValue(membership_mat, cluster_centers): # Updating the membership value
    p = float(2/(m-1))
    for i in range(n):
        x = list(df.iloc[i])
        distances = [np.linalg.norm(np.array(list(map(operator.sub, x, cluster_centers[j])))) for j in range(k)]
        for j in range(k):
            den = sum([math.pow(float(distances[j]/distances[c]), p) for c in range(k)])
            membership_mat[i][j] = float(1/den)       
    return membership_mat

def getClusters(membership_mat): # getting the clusters
    cluster_labels = list()
    for i in range(n):
        max_val, idx = max((val, idx) for (idx, val) in enumerate(membership_mat[i]))
        cluster_labels.append(idx)
    return cluster_labels

def fuzzyCMeansClustering(): #cluster centers are at Random vectors from data
    # Membership Matrix
    membership_mat = initializeMembershipMatrix()
    curr = 0
    acc=[]
    while curr < MAX_ITER:
        cluster_centers = calculateClusterCenter(membership_mat)
        membership_mat = updateMembershipValue(membership_mat, cluster_centers)
        cluster_labels = getClusters(membership_mat)
        
        acc.append(cluster_labels)
        
        if(curr == 0):
            print("Cluster Centers:")
            print(np.array(cluster_centers))
        curr += 1
    print("---------------------------")
    print("Partition matrix:")
    print(np.array(membership_mat))
    #return cluster_labels, cluster_centers
    return cluster_labels, cluster_centers, acc

labels, centers, acc = fuzzyCMeansClustering()

#Accuracy calculation
a = accuracy(labels, class_labels)

print(a)

acc_lis = [] 
for i in range(0,len(acc)):
    val = accuracy(acc[i], class_labels)
    acc_lis.append(val)

acc_lis = np.array(acc_lis) #calculating accuracy and std deviation 100 times
print("mean=",np.mean(acc_lis))
print("Std dev=",np.std(acc_lis))

print("Accuracy = " + str(round(a, 2)))

print("Cluster center vectors:") #final cluster centers
print(np.array(centers))

# Reference to FCM
#https://www.kaggle.com/prateekk94/fuzzy-c-means-clustering-on-iris-dataset

#plotting the labels predicted
plt.hist(labels,bins=11)
plt.title("Predicted Labels from FCM")